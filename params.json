{
  "name": "JonoonDB",
  "tagline": "JonoonDB - It's a row store...It's a column store...NO! It's JonoonDB",
  "body": "**Introduction**\r\n\r\nJonoonDB is a one size fits all database. Its aim is to do what specialized databases (row stores, column stores, nosql stores etc.) do at equal or better performance. It will be the database to end all databases.\r\n\r\n**Not another database! Don't we have enough already?**\r\n\r\nWell we have too many, somewhere north of 100 actually. But the real question is why do we have so many databases. If it’s a solved problem, we should have maybe less than 5 right? The truth is a lot of databases just cover a thin vertical slice of the overall data use cases. We need a database that can cover all the data uses cases or at least try. JonoonDB is an attempt to write such a database.\r\n\r\n**So you want to write a general purpose database. That's nuts. You cannot have one size fit all.**\r\n\r\nI would agree if we were talking about a pair of shoe or socks. But we are talking about a pretty sophisticated piece of software (JonoonDB) that is already catering to a wide range of use cases.\r\n\r\n**I keep hearing \"wide range of use cases\". What are these use cases?**\r\n\r\nThe most important ones are:\r\n\r\n1. Handle complex schema (Nesting, lists etc.)\r\n2. Handle schema evolution\r\n3. Handle OLTP and OLAP queries\r\n4. Handle high concurrency\r\n5. Handle fast get/put of entire records\r\n6. Support SQL\r\n\r\n**Ok I see, you want a database that can have the best qualities of a row store, column store and a NoSQL document store. But how is it even possible?**\r\n\r\nThe secret sauce is that JonoonDB internally keeps the same record in many different forms. This allows JonoonDB to behave as a row store, column store or a document store depending upon the query. JonoonDB's query planner is even smart enough to use these different forms in a single query plan to perform really fast queries.\r\n\r\n**Wouldn't keeping data in many different forms make the writes extremely slow?**\r\n\r\nJonoonDB uses a row oriented format for on disk representation. In addition, it allows the user to create different kinds of indexes (InvertedCompressedBitmaps, Vector and more to come.) that are only stored in memory. Keeping the indexes in memory allows us to do very fast inserts as compared to traditional databases.\r\n\r\n**So you are an in-memory database right?**\r\n\r\nNo. Everything you write to the database is reliably written to the disk in a transaction. It’s even protected against process and OS crash. However, to get the best performance the indexes need to fit in memory and that is a recommendation that all leading database have so there is nothing new here.\r\n\r\n**But what happens when the process restarts?**\r\n\r\nThe indexes have to be rebuilt and this can take time that is proportional to your database size. It will reduce your database availability and the way we propose to make JonoonDB highly available is to use replica sets (Part of the JonoonDB roadmap).\r\n\r\n**Are there any other benefits?**\r\n\r\nGlad you asked!\r\n* **Embed JonoonDB:** JonoonDB is shipped as a library so you can host the database in your process. This means you can avoid network round trip and achieve in-memory speeds.\r\n* **NoORM:** If your application uses the same storage format as JonoonDB then you can avoid the mapping between application and database format. Currently we only support flatbuffers but in future we will support other popular formats such as Cap'n Proto and Protobuf.\r\n* **Cross platform:** Supported on Windows, Linux and Mac OS X.\r\n* **LGPL license:** Can be used in both open source and closed source projects.\r\n* **Extensible:** JonoonDB allows you to plugin your own indexers and encoding formats. ",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}